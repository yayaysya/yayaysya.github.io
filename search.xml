<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[打印10000以内的质数]]></title>
    <url>%2F2017%2F11%2F21%2FSuanFaZhiShu1121%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍打印10000以内质数的方法 更新记录 2017/11/16:写完初稿 2017/11/21:发布到博客 教科书算法对每个数, 使用从2到n-1的数字作为除数,如果没有能除尽的数存在, 则这个数字为质数轻度改良使用从2到n的开根的数作为除数,可以降低算法复杂度 较好的算法使用分而治之的思路, 去除掉一些原本不可能存在的数, 剩下的就是可能的数字 新建一个10000长度的数组表,取出数字2, 然后去掉所有他的倍数取出数字3, 然后去除所有它的倍数取出下一个数, 然后去除所有它的倍数直到数字500这样的算法复杂度为O(1/8*n^2) //不准确, 应该有更好的方式具体的实现1//TBD]]></content>
      <categories>
        <category>suanfa</category>
      </categories>
      <tags>
        <tag>sufan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绪论]]></title>
    <url>%2F2017%2F11%2F21%2FSuanFa1121%2F</url>
    <content type="text"><![CDATA[之前觉得算法不太重要, 因为实际编程的过程中没有遇到多少.但是在做题的时候,发现自己不太会做的题目好多都是有固定的算法套路的自己基础的缺失, 导致了自己错过了太多的机会这是计算机专业的基础, 相当于概率论在通信工程中的地位.对于基础一定要熟练掌握 更新记录 2017/11/15:写完初稿 2017/11/21:发布到博客 主要分成两个大的方向来进行总结 细细啃算法这个方向主要记录常见算法的理论知识, 通晓原理才能解决问题 &lt;细细啃算法&gt;涉及的方面 二分搜索 Binary Search 分治 Divide Conquer 宽度优先搜索 Breadth First Search 深度优先搜索 Depth First Search 回溯法 Backtracking 双指针 Two Pointers 动态规划 Dynamic Programming 扫描线 Scan-line algorithm 快排 Quick Sort 快速啃算法这个方向主要记录常见的算法题目的解决方法以及思路, 更偏向于实战 快速啃算法-打印10000以内的质数 (相关的文章更新可能会有延迟, 还是应该去参考蜀道难目录下的更新进度)]]></content>
      <categories>
        <category>suanfa</category>
      </categories>
      <tags>
        <tag>sufan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针迷惑点清扫]]></title>
    <url>%2F2017%2F11%2F21%2FCLang1121%2F</url>
    <content type="text"><![CDATA[本节是自己有时候对指针的使用犯迷糊的时候, 自己做的小实验, 目的是加深自己对指针使用方法的理解 更新记录 2017/11/19:写完初稿: 指针长度问题, 指针的加一问题 2017/11/21: 增加了字符串数组的使用问题 指针长度问题前几天在网上看到说1char *a[10]; 问sizeof(a)的大小, 网上有人说是4, 认为当做指针看待 但是a明明就是一个数组名, 只是中间存的全部是指针这样sizeof(a)的大小应该是40 网上也找不到什么说法 于是自己做了实验1234567#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char *a[10]; printf("*a[10] sizeof(a) = %d\n", sizeof(a));&#125; 输出的结果1*a[10] sizeof(a) = 40 所以应该把char *a[10]中a当做数组名来看待 大小应该是40 指针加一问题12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; char *a; int *b; float *c; double *d; printf("addr:\na = %p, a+1 = %p\n", a, a+1); printf("b = %p, b+1 = %p\n", b, b+1); printf("c = %p, c+1 = %p\n", c, c+1); printf("d = %p, d+1 = %p\n", d, d+1); /*ptr xiangjian*/ int *m, *n; n = m+1; printf("n = m +1\naddr: m n (%p %p)\nn-m %p\n", m, n, n-m);&#125; 结果12345678addr:a = 0x4d5cc0, a+1 = 0x4d5cc1b = 0x4d4ff4, b+1 = 0x4d4ff8c = 0x80484a0, c+1 = 0x80484a4d = 0x8048310, d+1 = 0x8048318n = m +1addr: m n (0x80484ab 0x80484af)n-m 0x1 //相减结果为1 得出结论: 指针加一后, 其地址是增加对应的数据类型长度 加一后的指针减去原指针, 得到的结果是相差多少个数据类型, 并不是实际的地址长度差值. 想想地址增加数据类型长度也是对的每个指针指向一个字节(8位/16位), 如果该数据是多个字节(除了char), 那么加一后挪动一个数据长度是比较符合逻辑的. 要不然使用起来很麻烦. 相应的可以推论, 结构体指针加一, 那么肯定地址也是加上结构体的长度 字符指针的使用问题对于用法1char *p = "12345"; //-------------------A 之前一直抱有疑问, 这种用法到底对不对, 因为”12345”并没有创立这个变量总觉得下面这种用法才是正确的1char p[] = "12345"; //---------------------B 今天经过验证, 发现这两种方法都是允许使用的但是有很大的区别 A中”12345”是存在常数变量区域, 也就是不可更改的, 只能读取使用, 不能写入 B中”12345”是存在p[]数组里面的, 也就是存在栈里面, 所以可以读取和写入 实验如下结果可见, 当我试图改变p指向的值的时候, 由于我去改变常变量区域的值, 所以发生了段错误.]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>ptr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红绿灯网络传输设计]]></title>
    <url>%2F2017%2F11%2F21%2Fnetwork1121%2F</url>
    <content type="text"><![CDATA[本节是自己和同事一起设计的关于红绿灯传输的代码, 涉及socket的使用, setsockopt的使用以及作用fcntl控制接收为非阻塞的知识. 是很典型的网络传输控制方法 更新记录 2017/11/18:写完初稿 红绿灯代码数据传输设计函数返回值0表示成功, -1表示失败123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114void* its_thread_RGsignal( void* _param )&#123; struct sockaddr_in server_addr,client_addr; socklen_t addr_len; static time_t curr_seconds, prev_seconds = 0,flag=0; DAT_Signal_Light light_status,*p_light_status=NULL; int new_sock,pre_sock; int sc,ret,err; int on = 1; void *msg=NULL; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(FWD_RGL_PRT); server_addr.sin_addr.s_addr = htonl(INADDR_ANY);begin: sc = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); if(sc == -1) &#123; com_logfile(LOG_SYSTEM,"raw socket err 1\n"); goto begin; &#125; if(setsockopt(sc,SOL_SOCKET,SO_REUSEADDR, &amp;on,sizeof(on)) == -1) &#123; com_logfile(LOG_SYSTEM,"setsockopt err 2\n"); close(sc); goto begin; &#125; if(bind(sc,(struct sockaddr *)&amp;server_addr,sizeof(server_addr))!=0) &#123; com_logfile(LOG_SYSTEM,"raw socket bind error\n"); close(sc); goto begin; &#125; if(listen(sc,1) != 0) &#123; com_logfile(LOG_SYSTEM,"raw socket listen error\n"); close(sc); goto begin; &#125; fcntl(sc, F_SETFL, fcntl(sc, F_GETFD, 0)|O_NONBLOCK); while(1) &#123; //printf("-----------111111\n"); new_sock = accept(sc,(struct sockaddr *)&amp;client_addr,&amp;addr_len); if(new_sock &lt; 0) &#123; //printf("-----------new_sock = %d\n",new_sock); usleep(200*1000); continue; &#125; else &#123; if(new_sock!=pre_sock) &#123; pre_sock=new_sock; LOG_PRINT(LOG_SYSTEM,"new_sock=%d\n",new_sock); fcntl(new_sock, F_SETFL, fcntl(new_sock, F_GETFD, 0)|O_NONBLOCK); &#125; prev_seconds = time(NULL); //printf("new_sock = %d\n",new_sock); while(1) &#123; curr_seconds = time(NULL); ret=SignalLight_status(new_sock,&amp;light_status); if(ret==0) &#123; LOG_PRINT(LOG_ERROR," (%d %d %d %d) \n",light_status.id,light_status.dev_id, light_status.Low_Eight,light_status.Height_Eight); OSMutexLock(&amp;m_netsignal_lock); g_light_status.id=light_status.id; g_light_status.dev_id=light_status.dev_id; g_light_status.Height_Eight=light_status.Height_Eight; g_light_status.Low_Eight=light_status.Low_Eight; OSMutexUnlock(&amp;m_netsignal_lock); prev_seconds=curr_seconds; usleep(100*1000); &#125; else if(ret==-1) &#123; OSMutexLock(&amp;m_netsignal_lock); g_light_status.id=0; g_light_status.dev_id=0; g_light_status.Height_Eight=0; g_light_status.Low_Eight=0; OSMutexUnlock(&amp;m_netsignal_lock); LOG_PRINT(LOG_ERROR,"SOCKET FAILE!!! \n"); break; usleep(100*1000); &#125; else &#123; if(curr_seconds-prev_seconds&gt;3) &#123; OSMutexLock(&amp;m_netsignal_lock); g_light_status.id=0; g_light_status.dev_id=0; g_light_status.Height_Eight=0; g_light_status.Low_Eight=0; OSMutexUnlock(&amp;m_netsignal_lock); LOG_PRINT(LOG_ERROR,"SOCKET FAILE!!! \n"); break; &#125; //com_logfile(LOG_ERROR,"Return Data Is Not Correct!!!\n"); usleep(100*1000); &#125; &#125; &#125; close(new_sock); pre_sock=0; &#125; return NULL;&#125; 代码分析1123server_addr.sin_family = AF_INET;server_addr.sin_port = htons(FWD_RGL_PRT);server_addr.sin_addr.s_addr = htonl(INADDR_ANY); 结构体 struct sockaddr_in需要填充的参数有三个1.sin_family: 协议类型AF_INET表示ipv4协议2.sin_port: 端口号端口号需要将本机字节序转换为网络字节序, 端口号一般为16位, 所以用htons来进行转换3.sin_addr_s_addr : ip地址INADDR_ANY表示本机所有的ip, 其实就是本机的ipip地址是32位的, 所以需要htonl来进行转换 代码分析2123456sc = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);if(sc == -1)&#123; com_logfile(LOG_SYSTEM,&quot;raw socket err 1\n&quot;); goto begin;&#125; socket有三个参数1.网络层协议用的是ipv4, 所以是PF_INET 关于AF_INET和PF_INET理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。 2.数据传输方式 SOCK_STREAM 和 SOCK_DGRAMSOCK_STREAM 表示面向连接的数据传输方式, 数据可以准确的到达目的地, 不出损坏或者丢失 效率低 配合TCP协议使用SOCK_DGRAM 表示无连接的数据传输方式, 支付按传输数据, 不作数据校验, 丢了就丢了 效率高 配合UDP协议使用3.传输协议 IPPROTO_TCP 和 IPPTOTO_UDPIPPROTO_TCP表示tcp传输协议IPPIPOTO_UDP表示udp传输协议可以将传输协议设置为0, 系统会根据第二个参数数据传输方式来自动使用相应的协议 常用12int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //IPPROTO_TCP表示TCP协议int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //IPPROTO_UDP表示UDP协议 返回-1为创建失败, 否则返回socket的fd 代码分析3123456789int on = 1;.... if(setsockopt(sc,SOL_SOCKET,SO_REUSEADDR, &amp;on, sizeof(on)) == -1) &#123; com_logfile(LOG_SYSTEM,"setsockopt err 2\n"); close(sc); goto begin; &#125; setsockopt作用是设置socket的状态setsockopt参数分析(五个参数) 第一个参数创建的网络fd 第二个参数level参数level 代表欲设置的网络层, 一般设成SOL_SOCKET 第三个参数optname表示欲设置的选项这里的SO_REUSEADDR 允许在bind ()过程中本地地址可重复使用 第四个参数optval代表欲设置的值 第四个参数optlen 功能有两个方面一.改变了绑定时处理原地址冲突的处理方式 socket的绑定方式1.特定绑定, socket可以绑定到一个特定的ip和port2.通配绑定, 即绑定到INADDR_ANY3.默认情况下, 系统中如果存在两个socket, 那么两个socket不能绑定到相同的源ip和源端口即 socketA先绑定到通配地址0.0.0.0:21，后socketB绑定192.168.0.1:21将失败，不符合规则. 设置了SO_REUSEADDR之后, socketB将会绑定成功 二.改变了系统处于TIME_WAIT状态的socket看待方式 处于TIME_WAIT状态的socketsocket通常都有发送缓冲区，当调用send()函数成功后，只是将数据放到了缓冲区，并不意味着所有数据真正被发送出去。对于TCP socket，在加入缓冲区和真正被发送之间的时延会相当长。这就导致当close一个TCP socket的时候，可能在发送缓冲区中保存着等待发送的数据。为了确保TCP的可靠传输，TCP的实现是close一个TCP socket时，如果它仍然有数据等待发送，那么该socket会进入TIME_WAIT状态。这种状态将持续到数据被全部发送或者发生超时（这个超时时间通常被称为Linger Time，大多数系统默认为2分钟）。总结就是关闭socket的时候, 会进入一个TIME_WAIT的状态,想想就是四次挥手的时候的TIME_WAIT的状态 默认情况下, 对于一个处于TIME_WAIT状态的socketA, 如果此时有一个socketB来连接相同的ip和端口, 就会失败因为socketA没有真正关闭, 等socketA真正关闭的时候, 才会连接socketB. 但是如果此时, 设置了SO_REUSEADDR, 那么内核将忽略TIME_WAIT的状态, 使B绑定成功 代码分析4123456789101112if(bind(sc, (struct sockaddr *)&amp;server_addr, sizeof(server_addr))!=0)&#123; com_logfile(LOG_SYSTEM,"raw socket bind error\n"); close(sc); goto begin;&#125;if(listen(sc,1) != 0)&#123; com_logfile(LOG_SYSTEM,"raw socket listen error\n"); close(sc); goto begin;&#125; 对于bind函数, 一共有三个参数 参数1: socket fd 参数2: server的信息注意类型转换, 要从sockaddr_in指针强制类型转换为sockaddr型的指针关于server_addr,前面已经有了描述: 协议, 地址, 端口 参数3: 信息的长度sizeof(server_addr)即可 对于listen函数, 一共有两个参数socket fd 和 不为0的常数 代码分析51fcntl(sc, F_SETFL, fcntl(sc, F_GETFD, 0)|O_NONBLOCK); fcntl功能: 改变文件描述符的性质fcntl参数分析 参数1: 将要改变的文件fd 参数2: 命令F_GETFD 取得文件描述符标志 F_GETFD 取得与文件描述符fd联合的close-on-exec标志，类似FD_CLOEXEC。如果返回值和FD_CLOEXEC进行与运算结果是0的话，文件保持交叉式访问exec()，否则如果通过exec运行的话，文件将被关闭(arg 被忽略)在修改文件描述符标志或文件状态标志时必须谨慎，先要取得现在的标志值，然后按照希望修改它，最后设置新标志值。不能只是执行F_SETFD或F_SETFL命令，这样会关闭以前设置的标志位。 F_GETFL 取得文件状态标志F_SETFL 设置文件状态标志 参数3: 设置的标志O_NONBLOCK 非阻塞I/O，如果read(2)调用没有可读取的数据，或者如果write(2)操作将阻塞，则read或write调用将返回-1和EAGAIN错误就是将套接字设置为非阻塞的模式, 一旦无数据可读, 或者write操作阻塞, 那么将直接返回 代码分析61234567new_sock = accept(sc,(struct sockaddr *)&amp;client_addr,&amp;addr_len);if(new_sock &lt; 0)&#123; //printf(&quot;-----------new_sock = %d\n&quot;,new_sock); usleep(200*1000); continue;&#125; accept函数用来连接一个client参数有三个 1.参数1: socket_fd 2.参数2: client_addr 3.参数3: addr_len 参数配置和bind相同, 就是client_addr是获取的客户端相关信息 代码分析61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071while(1) &#123; //printf("-----------111111\n"); new_sock = accept(sc,(struct sockaddr *)&amp;client_addr,&amp;addr_len); if(new_sock &lt; 0) &#123; //printf("-----------new_sock = %d\n",new_sock); usleep(200*1000); continue; &#125; else &#123; if(new_sock!=pre_sock) &#123; pre_sock=new_sock; LOG_PRINT(LOG_SYSTEM,"new_sock=%d\n",new_sock); fcntl(new_sock, F_SETFL, fcntl(new_sock, F_GETFD, 0)|O_NONBLOCK); &#125; prev_seconds = time(NULL); //printf("new_sock = %d\n",new_sock); while(1) &#123; curr_seconds = time(NULL); ret=SignalLight_status(new_sock,&amp;light_status); if(ret==0) &#123; LOG_PRINT(LOG_ERROR," (%d %d %d %d) \n",light_status.id,light_status.dev_id, light_status.Low_Eight,light_status.Height_Eight); OSMutexLock(&amp;m_netsignal_lock); g_light_status.id=light_status.id; g_light_status.dev_id=light_status.dev_id; g_light_status.Height_Eight=light_status.Height_Eight; g_light_status.Low_Eight=light_status.Low_Eight; OSMutexUnlock(&amp;m_netsignal_lock); prev_seconds=curr_seconds; usleep(100*1000); &#125; else if(ret==-1) &#123; OSMutexLock(&amp;m_netsignal_lock); g_light_status.id=0; g_light_status.dev_id=0; g_light_status.Height_Eight=0; g_light_status.Low_Eight=0; OSMutexUnlock(&amp;m_netsignal_lock); LOG_PRINT(LOG_ERROR,"SOCKET FAILE!!! \n"); break; usleep(100*1000); &#125; else &#123; if(curr_seconds-prev_seconds&gt;3) &#123; OSMutexLock(&amp;m_netsignal_lock); g_light_status.id=0; g_light_status.dev_id=0; g_light_status.Height_Eight=0; g_light_status.Low_Eight=0; OSMutexUnlock(&amp;m_netsignal_lock); LOG_PRINT(LOG_ERROR,"SOCKET FAILE!!! \n"); break; &#125; //com_logfile(LOG_ERROR,"Return Data Is Not Correct!!!\n"); usleep(100*1000); &#125; &#125; &#125; close(new_sock); pre_sock=0; &#125; 连接与断开的逻辑 关于recv函数的返回值分析1234567891011121314151617181920212223242526272829int ivs_nonblocking_read(int sockfd, char *buf, int len)&#123; int ret;READ_AGAIN: ret = recv(sockfd, buf, len, 0); //the connection is closed by peer if(ret == 0) return -1; else if(ret == -1) &#123; if(errno == EINTR) &#123; ret = 0; goto READ_AGAIN; &#125; else if(errno == EAGAIN) &#123; return 0; &#125; else &#123; return -1; &#125; &#125; return ret;&#125; 对于recv函数返回值 如果&gt;0, 表示接受成功, 返回值为接收到的字节数目 如果=0, 表示另一端已经关闭了连接 如果&lt;0, 则表示接受失败, 需要通过errno的值做进一步分析EINTR：操作被信号中断EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时这种情况下应该再去接收, 而不是直接返回当然遇到, 一些其他errno值也应该返回 详细逻辑分析1.内层循环(已经连上)recv相关红绿灯的数据 如果成功, 返回值为0继续内存循环接收红绿灯数据, 更新prev时间为最新的时间, 等待100ms, 重新接收数据 如果失败, 而且返回值为-1表示recv接收到0, 表示对端关闭了连接, 这种情况break, 然后关闭了连接, 在外层的循环accept新连接 如果失败, 返回值为其他值表示由于协议解析失败或者recv被打断造成的问题, 这种情况, 等待100ms, 然后重新接接收, 并不更新时间, 如果这种状态持续3s, 那么就断开连接. 2.外层循环如果退出内层循环, 就关闭上一次的链接, 继续accept接收客户端的连接.]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[execve]]></title>
    <url>%2F2017%2F10%2F18%2FLinuxExecve%2F</url>
    <content type="text"><![CDATA[本节可以学到: execve()的使用; execve()的作用: 在进程中启动新程序 更新记录 2017/10/18:写完初稿 execve使用场景在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序 头文件与函数原型 头文件#include&lt;unistd.h&gt; 函数定义 1int execve(const char *filename, char *const argv[ ], char *const envp[ ]); 函数说明execve()用来执行参数filename字符串所代表的文件路径， 第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束 最后一个参数则为传递给执行文件的新环境变量数组 相关函数exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数。 例子栗子11234567#include&lt;unistd.h&gt;int main()&#123; char *argv[ ]=&#123;"ls", "-al", "/etc/passwd", NULL&#125;; char *envp[ ]=&#123;"PATH=/bin", NULL&#125; execve("/bin/ls", argv, envp); &#125; 栗子21234567891011121314151617181920212223/* execve.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;intmain(int argc, char *argv[])&#123; char *newargv[] = &#123; NULL, "hello", "world", NULL &#125;; char *newenviron[] = &#123; NULL &#125;; if (argc != 2) &#123; fprintf(stderr, "Usage: %s &lt;file-to-exec&gt;\n", argv[0]); exit(EXIT_FAILURE); &#125; newargv[0] = argv[1]; execve(argv[1], newargv, newenviron); perror("execve"); /* execve() returns only on error */ exit(EXIT_FAILURE);&#125; linux fork()和execve()的区别fork是分身，execve是变身。 exec系列的系统调用是把当前程序替换成要执行的程序，而fork用来产生一个和当前进程一样的进程（虽然通常执行不同的代码流）。通常运行另一个程序，而同时保留原程序运行的方法是，fork+exec。 总结exec系列主要的作用就是在进程中去启动另一个进程. 自己原本的程序就废掉了.具体编程的时候使用频率不高.不过涉及到进程关系, 最好还是了解一下 参考链接1.http://www.cnblogs.com/jxhd1/p/6706701.html2.http://man7.org/linux/man-pages/man2/execve.2.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>execve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wait与waitpid()]]></title>
    <url>%2F2017%2F10%2F18%2FLinuxWait%2F</url>
    <content type="text"><![CDATA[本节可以学到: wait与waitpid()的使用 更新记录 2017/10/18:写完初稿 waitpid()函数：中断(结束)进程函数使用场景希望知道某一个自己创建的子进程何时结束，从而方便父进程做一些处理动作。 头文件与函数原型 头文件:#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; 定义函数:pid_t waitpid(pid_t pid, int * status, int options); 函数说明 如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行.直到有信号来到或子进程结束. 如果在调用wait()时子进程已经结束, 则wait()会立即返回子进程结束状态值. 如果没有子进程, 就返回错误 参数 子进程的结束状态值会由参数status 返回, 而子进程的进程识别码也会一起返回. 如果不在意结束状态值, 则参数status 可以设成NULL. 参数pid 为欲等待的子进程识别码, 其他数值意义如下：1、pid&lt;-1 等待进程组识别码为pid绝对值的任何子进程.2、pid=-1 等待任何子进程, 相当于wait().3、pid=0 等待进程组识别码与目前进程相同的任何子进程.4、pid&gt;0 等待任何子进程识别码为pid 的子进程. 参数option 可以为0 或下面的OR 组合： WNOHANG：如果没有任何已经结束的子进程则马上返回, 不予以等待.WUNTRACED：如果子进程进入暂停执行情况则马上返回, 但结束状态不予以理会. 子进程的结束状态返回后存于status, 底下有几个宏可判别结束情况 WIFEXITED(status)：如果子进程正常结束则为非0 值. WEXITSTATUS(status)：取得子进程exit()返回的结束代码, 一般会先用WIFEXITED来判断是否正常结束才能使用此宏. WIFSIGNALED(status)：如果子进程是因为信号而结束则此宏值为真 WTERMSIG(status)：取得子进程因信号而中止的信号代码, 一般会先用WIFSIGNALED 来判断后才使用此宏. WIFSTOPPED(status)：如果子进程处于暂停执行情况则此宏值为真. 一般只有使用WUNTRACED时才会有此情况. WSTOPSIG(status)：取得引发子进程暂停的信号代码, 一般会先用WIFSTOPPED 来判断后才使用此宏. 返回值如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno 中. wait函数头文件与函数原型 头文件：#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; 定义函数：pid_t wait (int * status); 函数说明作用: 相当于pid=-1的waitpid() 范例12345678910111213141516171819202122#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;main()&#123; pid_t pid; int status, i; if(fork() == 0) &#123; printf("This is the child process. pid =%d\n", getpid()); exit(5); &#125; else &#123; sleep(1); printf("This is the parent process, wait for child...\n"; pid = wait(&amp;status); i = WEXITSTATUS(status); printf("child's pid =%d . exit status=^d\n", pid, i); &#125;&#125; 执行：This is the child process. pid=1501This is the parent process, wait for child…child’s pid =1501, exit status =5 总结wait()函数涉及主进程与子进程的关系; 大体作用就是主进程阻塞,等子进程结束的信号waitpid()功能要更丰富, 可以涉及到进程组的等待 参考链接 http://blog.csdn.net/roland_sun/article/details/32084825 http://c.biancheng.net/cpp/html/289.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>wait</tag>
        <tag>waitpid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux前台进程与后台进程]]></title>
    <url>%2F2017%2F10%2F18%2FLinuxQianTai%2F</url>
    <content type="text"><![CDATA[本节可以学到: linux系统后台进程的概念 后台进程与前台进程的区别以及区分方法 后台进程相关的命令 更新记录 2017/10/18:写完初稿 后台进程后台进程（Background Process）是一种在不需用户干预的情况下运行于操作系统后台的计算机进程通常用于执行如日志记录、系统监测、作业调度以及用户提醒等任务。 区分方法 进程组ID在UNIX与类UNIX系统中，后台进程的进程组ID即PGID，可用ps命令获得）与控制终端进程组ID（即TPGID）不同，因而也可以此辨识后台进程。 用户交互后台程序基本上不和用户交互，优先级别稍微低一点前台的程序和用户交互，需要较高的响应速度，优先级别稍微高一点 相关命令123456789101112131415161. &amp; 最经常被用到这个用在一个命令的最后，可以把这个命令放到后台执行用户可使用“&amp;”操作符以启动进程并使之运行于后台，但标准输出（stdout）和标准错误输出（stderr）若未重定向则仍于前台（即当前父终端）输出。2. ctrl + z可以将一个正在前台执行的命令放到后台，并且暂停3. jobs查看当前有多少在后台运行的命令([作业号] 运行状态 作业名称)4.fg &lt;%int&gt;将后台中的命令调至前台继续运行5. bg &lt;%int&gt;将一个在后台暂停的命令，变成继续执行 SIGCONT–将后台任务唤醒，在后台运行；kill(pid,SIGCONT); The SIGCONT signal instructs the operating system to continue (restart) a process previously paused by the SIGSTOP or SIGTSTP signal. 参考链接1.https://my.oschina.net/u/2467198/blog/6190712.https://zh.wikipedia.org/wiki/%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>后台进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五.异常控制流]]></title>
    <url>%2F2017%2F10%2F18%2FCSAPP06%2F</url>
    <content type="text"><![CDATA[这一节主要涉及的概念是进程和信号;后期还需要补充: 进程同步相关知识; 异常处理相关知识 更新记录 2017/10/18:写完初稿 本节可以学到 物理地址和虚拟地址的区别 虚拟内存的作用 MMU地址翻译的简易原理 动态内存分配 内存使用中常见的错误 异常控制流TBD 进程需要了解进程的工作机制 两个机制: 逻辑控制流: 通过上下文切换的内核机制来让每个程序都感觉自己在独占处理器 私有地址空间: 通过虚拟内存的机制让每个程序都感觉自己在独占内存 常用命令: top / htop pcb进程控制块 进程切换 内核通过上下文切换的方式让多个进程同时工作 进程在内存中的分布 对于单线程因为是独占CPU, 所以不需要保存寄存器的值(cpu中的几个寄存器) 对于多线程因为进程切换, 所以内存中需要一块区域, 用来保存寄存器的值, 方便下次执行的时候恢复 CPU交替执行不同的进程;虚拟内存系统负责管理地址空间(虚拟内存的作用2) 内核对切换进程进行调度 Linux进程控制系统调用的错误处理在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 errno 这个全局变量来表示错误的原因。 ### 两个规则： 对于每个系统调用都应该检查返回值 当然有一些系统调用的返回值为void，在这里就不适用 使用123456//调用系统函数fork()if ((pid = fork()) &lt; 0) &#123; fprintf(stderr, "fork error: %s\n", strerror(errno)); exit(0);&#125; 也可以利用辅助函数123// 上面的片段可以写为if ((pid = fork()) &lt; 0) unix_error("fork error") 获取进程信息获取函数 pid_t getpid(void) //返回当前进程的pid pid_t getppid(vodi) //返回当前进程的ppid 进程的状态 运行Running: 正在被执行/等待执行/最终将会被执行 停止Stopped: 执行被挂起, 在进一步通知前不会计划执行 (相当于暂停) 终止Terminated: 进程被永久停止 (相当于关闭) 终止Terminated被终止的情况: 接到终止信号 main函数返回 调用了exit函数 exit函数函数原型void exit(int status); //status: 0表示正常结束, 非零表示出现错误结束 创建子进程(fork)fork函数原型1int fork(void); ### 特点 子进程会有相同且独立的虚拟地址空间 子进程会得到父进程已经打开的文件描述符 子进程的进程号与父进程不同 注意 并行执行, 所以子进程与父进程没有执行顺序的差别 拥有独立到的地址空间 父进程与子进程的stdout都会发送到标准输出 一般用fork函数的返回值来区分1234567pid = Fork();if (pid == 0)&#123; // Child printf("I'm the child!\n"); exit(0);&#125; 回收子进程僵尸进程:主进程已经终止, 子进程还在消耗资源, 这种子进程称之为僵尸进程 回收方法 父进程利用wait或者waitpid回收已经终止的子进程, 然后给系统提供相关信息, kernel就会把僵尸子进程删除 父进程不显示回收的话, 就会被init进程(pid==1)回收 长期运行的进程还是要显示回收的(shell, server..) 想在子进程中载入启发的程序execve函数 TBD 进程树利用pstree(也就是ps+tree)来查看进程树 前台进程与后台进程TBD 信号信号的作用 进程间通信的一种有限制的方式 一种异步的通知机制, 用来提醒进程一个事件已经发生 进程接收到信号后 任何非原子操作都将被打断 如果定义了信号处理函数, 那么他将被执行; 如果没有定义, 则执行系统默认的处理函数 进程的特点 信号是内核向当前进程发出的 信号的类型由1-30的整数定义 使用的具体场景 内核发送信号给进程 内核检测到了除零操作(SIGFPE)或者子进程终止(SIGCHLD)的系统事件 另一个进程调用了kill命令来请求内核发送信号给指定的进程 接收后的操作目标进程接收到信号, 内核会强制要求进程对于信号做出相应, 可以有几种不同的操作: 忽略这个信号 终止进程 捕获信号, 执行信号处理函数 疑问点:对于多线程程序,信号处理函数signal(SIGPIPE, SIG_IGN)的作用范围是所有线程吗?可以有办法打印出最先发出段错误信号的程序吗? 进程组每个进程都只属于一个进程组 函数 getpgrp() 返回当前进程的进程组 (get ps group) setpgid() 设置一个进程的进程组 (set ps group id) 使用 关闭进程组, 会关闭该进程组中所有的进程 ctrl+c 发送SIGINT信号, 默认终止进程; ctrl_z发送SIGTSTP信号, 默认挂起进程 ps命令STAT含义 第一个字母S: 睡眠 sleepingT: 停止 stoppedR: 运行 running第二个字母s: 会话管理者 session leader+: 前台进程组 进程利用kill发送信号的典型例子1234567891011121314151617181920212223void forkandkill()&#123; pid_t pid[N]; int i; int child_status; for (i = 0; i &lt; N; i++) if ((pid[i] = fork()) == 0) while(1) ; // 死循环 for (i = 0; i &lt; N; i++) &#123; printf("Killing process %d\n", pid[i]); kill(pid[i], SIGINT); &#125; for (i = 0; i &lt; N; i++) &#123; pid_t wpid = wait(&amp;child_status); if (WIFEXITED(child_status)) printf("Child %d terminated with exit status %d\n", wpid, WEXITSTATUS(child_status)); else printf("Child %d terminated abnormally\n", wpid); &#125;&#125; 接收信号默认动作每个信号都有一个预定义的默认动作 终止进程 终止进程并 dump core 停止进程，收到 SIGCONT 信号之后重启 忽略信号 修改默认动作-signal函数函数原型1handler_t *signal(int signum, handler_t *handler) 添加signal(SIGINT, …)即使按下ctrl+c也不会造成程序的终止123456789int main()&#123; // 设定 SIGINT 处理器 if (signal(SIGINT, sigint_handler) == SIG_ERR) unix_error("signal error"); // 等待接收信号 pause(); return 0;&#125; 信号处理器被其他信号中断 阻塞信号被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作 阻塞和忽略的区别只要信号被阻塞就不会递达, 此时信号处于未决状态; 而忽略是在递达之后可选的一种处理动作 信号传递的状态 产生(Generation) 未决(Pending): 信号从产生到递达之间的状态 递达(Delivery): 实际执行信号的处理动作称为信号递达 显示地阻塞信号如果想显示阻塞信号, 就要用到信号集操作函数 sigemptyset - 创建空集 sigfillset - 把所有的信号都添加到集合中（因为信号数目不多） sigaddset - 添加指定信号到集合中 sigdelset - 删除集合中的指定信号 sigprocmask -改变信号的阻塞状态(设置阻塞/取消阻塞) 例子12345678910sigset_t mask, prev_mask;Sigemptyset(&amp;mask); // 创建空集Sigaddset(&amp;mask, SIGINT); // 把 SIGINT 信号加入屏蔽列表中// 阻塞对应信号，并保存之前的集合作为备份Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);...... // 这部分代码不会被 SIGINT 中断...// 取消阻塞信号，恢复原来的状态Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL); 非本地跳转的概念和意义本地跳转goto语句的流程跳转, 都是在一个函数内的跳转非本地跳转setjmp和longjmp配合的跳转, 可以从一个函数跳转到另一个函数 setjmp的含义类似: 设置调回点longjmp的含义: 跳转到调回点 例子12345678910111213141516171819202122232425jmp_buf env;P1()&#123; if (setjmp(env)) &#123; // 跳转到这里 &#125; else &#123; P2(); &#125;&#125;P2()&#123; ... P2(); ... P3();&#125;P3()&#123; longjmp(env, 1);&#125; 其他知识并发与并行并发(concurrent)一个cpu, 通过上下文切换间断执行多个进程, 来模拟多个进程并行并行(parallel)多个cpu真的同时执行各自的进程 参考链接1.https://akaedu.github.io/book/ch33s03.html2.http://wdxtub.com/2016/04/16/thin-csapp-5/]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>小土刀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七.虚拟内存与动态内存分配]]></title>
    <url>%2F2017%2F10%2F17%2FCSAPP08%2F</url>
    <content type="text"><![CDATA[这一节由于经常需要用, 所以提前看了.这一节涉及的知识包括:物理地址和虚拟地址;虚拟内存的作用;MMU地址翻译… 更新记录 2017/10/17:写完初稿 本节可以学到 物理地址和虚拟地址的区别 虚拟内存的作用 MMU地址翻译的简易原理 动态内存分配 内存使用中常见的错误 物理地址和虚拟地址的区别通过 MMU(Memory management unit)把虚拟地址(Virtual Address, VA)转换为物理地址(Physical Address, PA) 虚拟内存在缓存、内存管理与保护中的角色使用虚拟内存的原因： 可以更有效率的使用内存：使用DRAM当做部分的虚拟地址空间的缓存 简化内存管理：每个进程都有统一的线性地址空间 隔离地址控件：进程之间不会相互影响；用户程序不能访问内核信息和代码 作为缓存工具 DRAM的作用相当于缓存. 在 DRAM 中的每个缓存块(cache block)就称为页(page) 由于DRAM速度比较快, 所以我们的目标就是尽量从DRAM中拿数据 具体的做法-通过页表来管理 在 DRAM 中，每个进程都有自己的页表 虚拟内存通过页表来访问所需要的数据,访问的时候就在页表中查找如果找到: 就直接访问DRAM中页表对应的数据块;如果没找到: 此时就需要从磁盘复制到DRAM1.触发 Page fault，也就是一个异常2.Page fault handler 会选择 DRAM 中需要被置换的 page，并把数据从磁盘复制到 DRAM 中3.重新执行访问指令，这时候就会是 page hit 页表中null仔细留意上面的页表，会发现有一个条目是 null，也就是没有分配。具体的分配过程（比方说声明了一个大数组），就是让该条目指向虚拟内存（在磁盘上）的某个页，但并不复制到 DRAM，只有当出现 page fault 的时候才需要拷贝数据。 作为内存管理的工具每个进程都有自己的虚拟地址空间，这样一来，对于进程来说，它们看到的就是简单的线性空间（但实际上在物理内存中可能是间隔、支离破碎的） 每个虚拟页都可以被映射到任何的物理页上。 如果两个进程间有共享的数据，那么直接指向同一个物理页即可（也就是上图 PP 6 的状况，只读数据） 作为内存保护工具页表中的每个条目的高位部分是表示权限的位MMU 可以通过检查这些位来进行权限控制（读、写、执行） 地址翻译 掌握虚拟内存到物理内存的翻译机制 理解现代计算机系统中虚拟内存的应用 了解一下 Page Hit 和 Page Fault的具体流程 具体的详细页转换细节先暂时不了解, 之后有空补充 Page Hit 和 Page Fault的具体流程Page Hit 的情况主要有 5 步: CPU 首先把虚拟地址发送给 MMU， MMU 检查缓存(DRAM) 并从页表中得到对应的物理地址， 接着 MMU 把 物理地址 发送给 缓存/内存(DRAM)， 最后从 缓存/内存 中得到数据。 Page Fault 的情况第一次触发页错误会把页面载入内存/缓存，然后再以 Page Hit 的机制得到数据：这里有 7 步，前面和 Page Hit 是一致的，1-3.先把虚拟地址发给 MMU 进行检查，4.然后发现没有对应的页，于是触发异常5-6.异常处理器会负责从磁盘中找到对应页面 并与 缓存/内存中的页进行置换，7.置换完成后再访问同一地址，就可以按照 Page Hit 的方式来访问了 理解动态内存分配的基本概念 程序员通过动态内存分配（例如 malloc）来让程序在运行时得到虚拟内存。 动态内存分配器会管理一个虚拟内存区域，称为堆(heap)。 关于分配器 分配器以块为单位来维护堆，可以进行分配或释放。有两种类型的分配器： 显式分配器：应用分配并且回收空间（C 语言中的 malloc 和 free） 隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集） 分配器有如下的限制(了解即可)： 不能控制已分配块的数量和大小 必须立即响应 malloc 请求（不能缓存或者给请求重新排序） 必须在未分配的内存中分配 不同的块需要对齐（32 位中 8 byte，64 位中 16 byte） 只能操作和修改未分配的内存 不能移动已分配的块 内部碎片与外部碎片 内部碎片指的是对于给定的块，如果需要存储的数据(payload)小于块大小，就会因为对齐和维护堆所需的数据结构的缘故而出现无法利用的空间 外部碎片指的是内存中没有足够的连续空间如下图所示，内存中有足够的空间，但是空间不连续，所以成为了碎片 管理动态内存分配的三种方法涉及到分配的原理, 比较复杂, 暂时不需要了解 了解垃圾回收的基本原理涉及java等语言的垃圾回收, 暂时不了解 了解内存使用中常见的错误 不能假设堆中的数据会自动初始化为 0, 即malloc的数据不一定初始值为0 Overwriting Memory因为没有检查字符串的长度，超出部分就写到其他地方去了（经典的缓冲区溢出攻击也是利用相同的机制）例如gets(s)函数很容易造成内存溢出; 不要重复释放一段内存 Memory Leaks用完一定记得释放 size–`size–一句因为–` 的优先级比较高，所以实际上是对指针进行了操作这种容易混淆的东西还是别用了 其他页表与MMUMMU将VA映射到PA是以页（Page）为单位的，32位处理器的页尺寸通常是4KB。例如，MMU可以通过一个映射项将VA的一页0xb7001000~0xb7001fff映射到PA的一页0x2000~0x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。物理内存中的页称为物理页面或者页帧（Page Frame）。虚拟内存的哪个页面映射到物理内存的哪个页帧是通过页表（Page Table）来描述的，页表保存在物理内存中，MMU会查找页表来确定一个VA应该映射到什么PA。 操作系统和MMU是这样配合的： 操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中填写页表，然后用指令设置MMU，告诉MMU页表在物理内存中的什么位置。 设置好之后，CPU每次执行访问内存的指令都会自动引发MMU做查表和地址转换操作，地址转换操作由硬件自动完成，不需要用指令控制MMU去做。 我们在程序中使用的变量和函数都有各自的地址，程序被编译后，这些地址就成了指令中的地址，指令中的地址被CPU解释执行，就成了CPU执行单元发出的内存地址，所以在启用MMU的情况下，程序中使用的地址都是虚拟地址，都会引发MMU做查表和地址转换操作。那为什么要设计这么复杂的内存管理机制呢？多了一层VA到PA的转换到底换来了什么好处？All problems in computer science can be solved by another level of indirection.还记得这句话吗？多了一层间接必然是为了解决什么问题的，等讲完了必要的预备知识之后，将在第 5 节 “虚拟内存管理”讨论虚拟内存管理机制的作用。 参考链接1.http://linuxcc.top/2017/10/17/CSAPP08/2.https://akaedu.github.io/book/]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>小土刀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二.机器指令与程序优化]]></title>
    <url>%2F2017%2F10%2F16%2FCSAPP03%2F</url>
    <content type="text"><![CDATA[这一节涉及到cpu执行代码知识, 简单汇编知识, 以及详细的程序执行过程.另外包括结构体对齐知识, 和缓冲区溢出的相关知识. 更新记录 2017/10/16:写完初稿 本节可以学到 了解CPU如何进行指令计算 数据在内存中的存储方式, 结构体对齐 缓冲区溢出 汇编相关以及详细的程序执行(TBD) 了解CPU如何进行指令计算C语言代码–&gt;机器可执行的程序 C 语言代码(da.c, wang.c)经过编译器的处理(gcc -0g -S)成为汇编代码(da.s, wang.s) 汇编代码(da.s, wang.s)经过汇编器的处理(gcc 或 as)成为对象程序(da.o, wang.o) 对象程序(da.o, wang.o)以及所需静态库(lib.a)经过链接器的处理(gcc 或 ld)最终成为计算机可执行的程序 处理器是如何配合内存进行计算 程序计数器(PC, Program counter) - 存着下一条指令的地址，在 x86-64 中称为 RIP 寄存器(Register) - 用来存储数据以便操作 条件代码(Codition codes) - 通常保存最近的算术或逻辑操作的信息，用来做条件跳转 处理器能够执行的操作: 存取数据是在内存和寄存器之间传输数据 进行计算则是对寄存器或者内存中的数据执行算术运算 传输控制主要指非条件跳转和条件分支 关于传输控制 四个标识位（CF, ZF, SF, OF）就是用来辅助程序的流程控制的 CF: Carry Flag (针对无符号数) ZF: Zero Flag SF: Sign Flag (针对有符号数) OF: Overflow Flag (针对有符号数) 四个标志置位条件 如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置 如果 t 等于 0，那么 ZF 标识位会被设置 如果 t 小于 0，那么 SF 标识位会被设置 如果 2’s complement 溢出，那么 OF 标识位会被设置为 1（溢出的情况是 (a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>小土刀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一.数据表示]]></title>
    <url>%2F2017%2F10%2F10%2FCSAPP02%2F</url>
    <content type="text"><![CDATA[这一节的知识涉及数据表示等基础内容, 相当于对之前自己学的东西的查缺补漏.第一节毕竟简单, 很快就学完了, 涉及的知识也很零碎且基础不过像大端小端这种问题也是面试的时候常见的问题 更新记录 2017/10/10:写完初稿 本节可以学到 计算机架构 整数运算 浮点运算 数据类型字节数 大端与小端 计算机架构 计算机脱胎于图灵机的构想，简单来说，就是能够执行有限逻辑数学过程的计算模型。 冯诺依曼，1945不但提出了二进制的构想，更将计算机分成五大组件（存储器、控制器、运算器、输入、输出） 哈佛架构，它和冯诺依曼架构最大的区别在于能够同时访问数据和指令。ARM 架构可能是知名度最高的哈佛架构 冯诺依曼架构也有缺陷,比方说缓存溢出可以执行攻击者预订好的程序，给系统带来巨大的安全风险 整数运算整数以及浮点数运算的缺陷 整数溢出了，就成了负数 浮点数运算会损失部分精度 c语言的段错误 无论是 C 或者 C++ 都没有提供任何内存保护机制，再加上强大且危险的指针，出现溢出或者段错误实在是家常便饭。 右移运算一种是逻辑右移（左边补0），另一种是算术右移（左边补符号位）。为什么会有这两种?因为对应无符号数和有符号数的运算，有符号数的最高位（最左边）是符号位在负数的时候需要进行算术右移 编码 有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的 在进行有符号和无符号数的互相转换时： 具体每一个字节的值不会改变，改变的是计算机解释当前值的方式 如果一个表达式既包含有符号数也包含无符号数，那么会被隐式转换成无符号数进行比较 浮点数M为exp, E为frac浮点数的部分因为工作用的真的很少, 所以暂时不看了 数据类型字节数 大端与小端大端(Big Endian)与小端(Little Endian)，区别在于高位地址的位置例子假如变量 x 是 4 字节，值为 0x01234567 主机/网络字节序 Internet 数据(网络字节序)采用大端规则 x86 或 ARM 处理器都采用小端规则 转换函数htons():将16位无符号整数从本地字节序转换成网络字节序；htonl():将32位无符号整数从本地字节序转换成网络字节序；ntohs():将16位无符号整数从网络字节序转换成本地字节序；ntohl():将32位无符号整数从网络字节序转换成本地字节序； 扩展: 如何检查大小端1234567typedef unsigned char *pointer;void show_bytes(pointer start, size_t len) &#123;size_t i;for (i = 0; i &lt; len; i++)printf(&quot;%p\t0x%.2x\n&quot;, start+i, start[i]);printf(&quot;\n&quot;);&#125; 看看高字节对应的是高地址还是低地址, 对应大端和小端 参考链接 小土刀-不周山之读薄CSAPP-壹-数据表示]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>小土刀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零.深入理解计算机系统]]></title>
    <url>%2F2017%2F10%2F10%2FCSAPP01%2F</url>
    <content type="text"><![CDATA[对于经典书籍&lt;深入理解计算机系统&gt;, 自己并没有阅读过,但是自己在工作中发现, 自己遇到的很多问题都涉及到计算机系统(Linux)底层的一些原理, 而自己对于这些原理的认知缺乏给自己的工作带来了很多负面的影响.CSAPP这本书太厚, google后发现了小土刀这个博客, 这个博客的博文真的写的很棒, 对于知识的认知, 以及博主自己学习的经历与方法都对我有很大的启发. 更新记录 2017/10/10:写完初稿 学习的目的 为了让自己对计算机系统的原理有更深刻的理解. 自己本科并没有学习过这些计算机的知识, 其实也相当于补课了. 为了解决相关的bug, 自己之前遇到了很多个尚未解决的bug, 都是涉及到底层以及内存方面的问题, 比如内存泄漏, 内存越界, 这些问题在嵌入式系统中都很难解决, 希望阅读这本书可以让自己对这些问题有所启发 浅尝辄止 小土刀的博客是对CSAPP的读薄, 那我再去阅读小土刀的博文, 那就是对原书不深入的阅读了 知识很多, 但是大学的学习经验告诉我, 我不可能去读透每一本书, 但是学习一本书的主干这种能力我还是有的, 如果能够了解几大块知识的主干, 那我去读博客这个行为可以算是有意义了 关于坚持 自己最大的问题是就是坚持, 学习了很多的东西, 都是半途而废了. 毕竟一个人学习新东西的时候是最有精力的,但是学习了一些之后一遇到难学的知识点就学习不下去了, 就想放弃掉. 其实可以容忍这种行为, 毕竟自己还有工作生活, 外部的环境让自己难以继续下去的可能性也是有的. 这样, 如果自己决定那天学不下去了, 就宣布停更, 存档, 等之后过一段时间有兴趣了再接着学习下去 最后很感谢小土刀能写出这么棒的博文并且公开出去, 谢谢! 参考链接 小土刀]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>小土刀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统-linux虚拟内存管理]]></title>
    <url>%2F2017%2F10%2F09%2FLinuxKnowMem%2F</url>
    <content type="text"><![CDATA[写linux C语言程序的过程中, 经常遇到内存方面的问题, 内存泄漏, 内存越界, 段错误…这些问题都让人很头痛, 自己又对linux内存分布以及内存分配方式不是很了解,阅读了几篇文章, 总结了一下相关知识, 加深一下自己对这方面的了解 内存分布 内核空间与用户空间linux系统中, 内核空间和用户空间所占的虚拟内存比例为1:3 32 位系统有4G 的地址空间:其中0x08048000~0xbfffffff是用户空间，0xc0000000~0xffffffff是内核空间，包括内核代码和数据、进程相关的数据结构（如页表、内核栈）等。 虚拟地址与物理地址 每个进程都有独立的虚拟地址空间 虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间-属于用户空间)与物理地址进行映射，获得真正物理地址； 如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。(后面这一句不是很明白) 用户空间分布Linux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： 只读段该部分空间只能读，不可写；包括：代码段、rodata 段(C常量字符串和#define定义的常量) 数据段保存全局变量、静态变量的空间；其中数据段保存已经初始化且初始值不为0的全局变量和静态局部变量, bss段保存未初始化或者初始值为0的全局变量和静态局部变量 堆就是平时所说的动态内存， malloc/new 大部分都来源于此。堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。 内存映射段 如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。 在linux系统中, 如果通过malloc请求一大块内存, c运行库将创建一个匿名内存映射, ‘大块’意味着比MMAP_THRESHOLD还要大, 该常量的缺省值为128k, 可以通过mallopt()函数进行调整. 关于共享库的位置在2.6版本之前, 共享库从0x40000000开始的地址分配相应空间，并在程序装载时将其载入到该空间内存映射段被分为了两个部分, 从0x40000000划分开, 不到1G的空间和不到2G的空间,此时应用程序最大malloc空间为不到2G在2.6版本中, 共享库的装载地址已经被挪到靠近栈的位置了即0xBFxxxxxx附近.此时单次malloc最大空间理论值在2.9G左右 栈用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。作用: 为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。 函数调用过程信息: 函数参数, 函数返回地址 临时存储alloca函数分配的栈内内存 内核虚拟空间用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)。 栈与堆的区别 管理方式：栈由编译器自动管理；堆由程序员控制 生长方向：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。 空间大小：栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。 存储内容：栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。 分配方式：栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。 分配效率：栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。 分配后系统响应：只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。 碎片问题：栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。 参考链接 http://www.cnblogs.com/dongzhiquan/p/5621906.html http://www.cnblogs.com/clover-toeic/p/3754433.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题美化]]></title>
    <url>%2F2017%2F09%2F30%2FNextMeihua%2F</url>
    <content type="text"><![CDATA[看到网上各种折腾next主题的, 自己也想为自己的next主题添加一下东西, 也为了让自己以后写博客更有动力, 参考了很多网上的东西, 先暂时添加一下的内容, 以后如果发现好玩的还会去更新 美化内容主题选择一共四种主题可以选择12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 之前用的是Pisces, 刚才实验了Gemini, Gemini就是在Pisces的基础上将页面变成了卡片式样的其实觉得原始的主题Muse更好看, 但是这种侧边栏挺难受的所以决定还是回归到Gemini算了 颜色块标签next\source\css\custom\custom.styl添加代码(本文最后)使用的时候 这是颜色块标签 这是颜色块标签 颜色可以为yellow green blue purple red 文本框 这是带颜色的文本框 这是带颜色的文本框 颜色可以为yellow green blue purple red位置可以为left \ top \ right 修改侧边栏头像为旋转圆形修改文件~\hexo\themes\next\source\css\_common\components\sidebar\sidebar-author.styl原本是12345678.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color;&#125; 修改为1234567891011121314151617181920.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all;&#125;.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125; 成功添加后效果 添加鼠标样式themes/next/source/css/_custom/custom.styl中添加代码1234567// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 未找到合适的鼠标样式的图片, 先暂时不添加了TBD 文章的宽度参考wanzhiyu.top中的介绍 修改方法1.打开\themes\next\source\css\_common\components\post\post-expand.styl文件修改1@media (max-width: 767px) 为1@media (max-width: 1080px) 2.打开\themes\next\source\css\ _variables\base.styl修改123$main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px 为123$main-desktop = 1080px$main-desktop-large = 1200px$content-desktop = 810px 3.打开\themes\next\source\css\_schemes\Pisces\_layout.styl, 修改1234.header &#123; position: relative; margin: 0 auto; width: 1080px; 修改文章底部的#号实现方法修改/themes/next/layout/_macro/post.swig搜索rel=&quot;tag&quot;&gt;#修改为rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 效果 添加顶部加载条修改theme/next/_config.yml中将pace: false改为pace: true即可默认的颜色不太好看,之后有空换换其他的看看效果如何TBD 添加文章更新时间新的next主题有文章更新时间的设置, 在主题配置文件中, 设置 123456# Post meta display settingspost_meta: item_text: true created_at: true updated_at: true #显示文章更新时间 categories: true 写文章的时候直接在开头添加1updated: 2016-10-14 10:53:09 如果没有会显示文章默认的修改日期 使用 不蒜子 给站点添加统计next 主题支持 不蒜子 统计，设置 主题配置文件 如下即可 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 您是第 #&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: 个小伙伴 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 #&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: 次 # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 为网站添加图标 准备一张32x32的ico图标, 并且命名为favicon.ico, 将其放到themes/next/source/images中 修改主题配置文件12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico 遇到的问题 颜色标签不显示现在发现颜色标签还是不显示好吧, 是网络的问题, 刚才没有及时更新, 现在好了, 已经可以正常显示了 文章内链接颜色不变虽然修改过了custom.styl, 但是文章内的链接颜色依旧不变, 之后进行修改一下TBD 试验一下 可以正常显示蓝色链接了, 应该是按照markdown语法的链接才会有效 为了实现任意链接尝试按照另一种方法, 在themes\next\source\css\_common\components\post\post.styl中添加123456789// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #fc6423; border-bottom: none; &#125;&#125; 结果还是没用, 看来只能够按照markdown语法去写链接修改参考链接为markdown语法 颜色块代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342// Custom styles.//修改文章内链接文本样式.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125;//修改不在文章内的链接文本样式.link-blue&#123; color: #f36; &amp;:hover &#123; color: #f00; &#125;&#125;//修改文章内code样式code &#123;color:#fff;background:#333;&#125;//修改文章中图片样式，改为居中.posts-expand .post-body img &#123; margin: 0 auto;&#125;// 下载样式a#download &#123; display: inline-block; padding: 0 10px; color: #000; background: transparent; border: 2px solid #000; border-radius: 2px; transition: all .5s ease; font-weight: bold; &amp;:hover &#123; background: #000; color: #fff; &#125;&#125;//阅读全文样式.post-more-link .btn &#123; position:relative; border: 2px solid #000; border-radius: 2px; padding: 0 10px; font-weight: bold; background: transparent; transition: all .5s ease; &amp;:hover &#123; background: #000; color: #eee; &#125;&#125;//// 颜色块-黄span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb;&#125;// 颜色块-红span#inline-red &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #df3e3e;&#125;// 左侧边框红色块级p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb;&#125;//动画模块//第一篇博客中-精于心，简于形-的动画span#yu-1 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:110%; cursor:pointer; &amp;:hover &#123; background-color: #000; color: #fff; animation: animate-yu-1 3s ease-in; &#125;&#125;@keyframes animate-yu-1 &#123; 0% &#123; left:-10px; top:0px; &#125; 10% &#123; left:10px; top:0px; &#125; 20% &#123; left:-8px; top:0px; &#125; 30% &#123; left:8px; top:0px; &#125; 40% &#123; left:-5px; top:0px; &#125; 50% &#123; left:5px; top:0px; &#125; 60% &#123; left:-3px; top:0px; &#125; 70% &#123; left:3px; top:0px; &#125; 80% &#123; left:-1px; top:0px; &#125; 90% &#123; left:1px; top:0px; &#125; 100% &#123; left:0px; top:0px; &#125;&#125;//留言页面-[最近访客]-的样式span#yu-2 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:130%;&#125; 参考链接 http://www.lazyboy.site http://www.vitah.net/posts/20f300cc/ http://theme-next.iissnan.com http://codepub.cn/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令-free]]></title>
    <url>%2F2017%2F09%2F29%2FLinuxCommandFree%2F</url>
    <content type="text"><![CDATA[命令的使用 参数的含义1234567MEM： total：总计物理内存大小 used：已经使用的物理内存大小 free： 空闲的物理内存大小 shared：多个进程共享的内存空间 buffer：缓冲 cache：缓存 常用的选项1234567usage: free [-b|-k|-m|-g] [-l] [-o] [-t] [-s delay] [-c count] [-V] -b,-k,-m,-g show output in Bytes, KB, MB, or GB 用来指定输出的单位。 -l show detailed low and high memory statistics 可以看到详细的最大最小值 -o use old format (no -/+buffers/cache line) 以老的格式显示，没有-/+buffers/cache line那一行 -t display total for RAM + swap ：会显示内存的总和，包括物理内存和swap分区大小。 -s update every [delay] seconds ： 输出结果每秒刷新一次 -c update [count] times ：刷新次数 -V display version information and exit ：显示版本信息。 注意 buffer与cache buffer缓冲区:将数据缓冲下来，解决速度慢和快的交接；速度快的需要通过缓冲区将数据一点一点传给速度慢的区域。例如：从内存中将数据往硬盘中写入，并不是直接写入，而是缓冲到一定大小之后刷入硬盘中。cached缓冲区:实现数据的重复使用，速度慢的需要通过缓存将经常要用到的数据缓存起来，缓存下来的数据可以提供高速的传输给速度快的设备。例如：将硬盘中的数据读取出来放在内存的缓存区中，这样以后再次访问同一个资源，速度回快很多。目的:为了提高IO的性能, 性能调优清空cached与buffer:与/proc/sys/vm/drop_caches这个内核参数有关 swap分区 介绍:内存不够用的时候，从硬盘上找一部分空间，将内存中最近最少使用的数据挪到硬盘的空间里。这段在硬盘中的空间就是swap分区。 参考文献 1.http://www.stackops.info/2015/09/20/Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3-free/index.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vps和github下的博客建立(TBD)]]></title>
    <url>%2F2017%2F09%2F04%2FjianzhanNote1%2F</url>
    <content type="text"><![CDATA[自己原本的 vpn 到期了,服务商的网站不知道为什么打不开了. 可能是被关停了吧. 所以前段时间才想再买个 vpn ,查了很久发现说vps 用来clip墙 很合适, 所以就买了搬瓦工 最便宜的套餐.完成我的目的后, 发现vps光用来clip墙有点浪费, 于是就考虑把个人的博客建立在上面. 建站过程购买并设置vps选择合适的套餐简单的设置配置SS线下主机配置安装git bash安装hexovps配置安装nginx安装gitgithub配置遇到的问题安装过程中的问题使用中的问题参考链接]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图床服务]]></title>
    <url>%2F2017%2F09%2F01%2Ftuchuang%2F</url>
    <content type="text"><![CDATA[新建立的博客, 之后可能文章会比较多, 所以如果把图片全部放到vps中, 那么可能访问速度会比较慢.所以考虑图床服务, 大家都在用七牛云, 于是就拿它来试试 步骤注册七牛云账号点击这里注册七牛云 新建对象储存1.点击新建对象储存起一个存储空间名2.保存空间概览–测试域名3.点击个人面板–密钥管理保存AK 和 SK两个密钥 在Mpic中填写配置下载MPic软件Mpic地址 填写配置将之前的保存的AK SK密钥填写进去, 再将保存的测试域名填写进去 上传测试可以看到, 上传成功了 遇到的坑 填写MPic的时候, 域名选择成了https:, 导致图片总是出不来, 后来改成http:再传图片就好了 参考链接 1.在 iPic 中添加七牛云 2. 罗朝福 图床 神器]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2017%2F09%2F01%2FFirstDay%2F</url>
    <content type="text"><![CDATA[先聊两句虽说文章的名字是第一篇博客, 但是实际上自己写博客已经很久了, 只是之前一直在wordpress上面写, 虽然文章数量不少, 但是都是质量堪忧, 只起到了玩玩的目的.现在买了一个vps, 利用hexo来做了自己的博客, 希望之后能做成一个很好的博客网站, 分享自己觉得好玩的东西,同时与更多的老司机进行交流. 板块设定之前的网站一直都没有很好的条理, 感觉很乱, 现在觉得自己应该提前想好做那几块的东西.鉴于自己的工作以及兴趣爱好, 觉得暂时设定下面几个板块比较合适 生活杂记 好软挖掘 影视分享 技术小栈1 技术小栈2 技术小栈3 杂物箱 更新频率自己由于工作的原因, 时间一般不固定, 所以更新的可能不是很规律, 先这样吧, 等之后完善后看看是否能有规律的进行更新 关于自己github yayaysyaweibosongshouli]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
      <tags>
        <tag>tag1</tag>
      </tags>
  </entry>
</search>
